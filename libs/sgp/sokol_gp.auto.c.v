// NOTE this file is auto-generated by chew
module sgp

import sgp.c
import sokol.gfx

pub const used_import = c.used_import

//
// sokol_gp.h
//

// C typedef aliases used
// sgp_point -> sgp_vec2 -> Vec2

/*
TODO Non-numerical: #define SOKOL_GP_IMPL
*/

pub const sokol_gp_included = 1

pub const batch_optimizer_depth = 8

// Number of draw commands that the batch optimizer looks back.
pub const uniform_content_slots = 4

// Number of texture slots that can be bound in a pipeline.
pub const texture_slots = 4

/*
TODO Non-numerical: #define SOKOL_GP_API_DECL SOKOL_API_DECL
*/

/*
TODO Function: #define SOKOL_GP_API_DECL __declspec(dllexport)
*/

/*
TODO Function: #define SOKOL_GP_API_DECL __declspec(dllimport)
*/

/*
TODO Non-numerical: #define SOKOL_GP_API_DECL extern
*/

// SGPError is C.sgp_error
pub enum SGPError {
	no_error = C.SGP_NO_ERROR // 0,
	sokol_invalid = C.SGP_ERROR_SOKOL_INVALID
	vertices_full = C.SGP_ERROR_VERTICES_FULL
	uniforms_full = C.SGP_ERROR_UNIFORMS_FULL
	commands_full = C.SGP_ERROR_COMMANDS_FULL
	vertices_overflow = C.SGP_ERROR_VERTICES_OVERFLOW
	transform_stack_overflow = C.SGP_ERROR_TRANSFORM_STACK_OVERFLOW
	transform_stack_underflow = C.SGP_ERROR_TRANSFORM_STACK_UNDERFLOW
	state_stack_overflow = C.SGP_ERROR_STATE_STACK_OVERFLOW
	state_stack_underflow = C.SGP_ERROR_STATE_STACK_UNDERFLOW
	alloc_failed = C.SGP_ERROR_ALLOC_FAILED
	make_vertex_buffer_failed = C.SGP_ERROR_MAKE_VERTEX_BUFFER_FAILED
	make_white_image_failed = C.SGP_ERROR_MAKE_WHITE_IMAGE_FAILED
	make_common_shader_failed = C.SGP_ERROR_MAKE_COMMON_SHADER_FAILED
	make_common_pipeline_failed = C.SGP_ERROR_MAKE_COMMON_PIPELINE_FAILED
}

// BlendMode is C.sgp_blend_mode
pub enum BlendMode {
	@none = C.SGP_BLENDMODE_NONE // 0, No blending.
	// dstRGBA = srcRGBA
	blend = C.SGP_BLENDMODE_BLEND // Alpha blending.
	// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
	// dstA = srcA + (dstA * (1-srcA))
	add = C.SGP_BLENDMODE_ADD // Color add.
	// dstRGB = (srcRGB * srcA) + dstRGB
	// dstA = dstA
	mod = C.SGP_BLENDMODE_MOD // Color modulate.
	// dstRGB = srcRGB * dstRGB
	// dstA = dstA
	mul = C.SGP_BLENDMODE_MUL // Color multiply.
	// dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
	// dstA = (srcA * dstA) + (dstA * (1-srcA))
	num = C._SGP_BLENDMODE_NUM
}

[typedef]
struct C.sgp_isize {
pub mut:
	w int
	h int
}

pub type Isize = C.sgp_isize

[typedef]
struct C.sgp_irect {
pub mut:
	x int
	y int
	w int
	h int
}

pub type Irect = C.sgp_irect

[typedef]
struct C.sgp_rect {
pub mut:
	x f32
	y f32
	w f32
	h f32
}

pub type Rect = C.sgp_rect

[typedef]
struct C.sgp_textured_rect {
pub mut:
	dst Rect
	src Rect
}

pub type TexturedRect = C.sgp_textured_rect

[typedef]
struct C.sgp_vec2 {
pub mut:
	x f32
	y f32
}

pub type Vec2 = C.sgp_vec2

[typedef]
struct C.sgp_line {
pub mut:
	a Vec2
	b Vec2
}

pub type Line = C.sgp_line

[typedef]
struct C.sgp_triangle {
pub mut:
	a Vec2
	b Vec2
	c Vec2
}

pub type Triangle = C.sgp_triangle

[typedef]
struct C.sgp_mat2x3 {
	// TODO 	v [2][3]f32
}

pub type Mat2x3 = C.sgp_mat2x3

[typedef]
struct C.sgp_color {
pub mut:
	r f32
	g f32
	b f32
	a f32
}

pub type Color = C.sgp_color

[typedef]
struct C.sgp_uniform {
pub mut:
	size u32
	// TODO 	content [SGP_UNIFORM_CONTENT_SLOTS]f32
}

pub type Uniform = C.sgp_uniform

[typedef]
struct C.sgp_images_uniform {
pub mut:
	count u32
	// TODO 	images [SGP_TEXTURE_SLOTS]gfx.Image
}

pub type ImagesUniform = C.sgp_images_uniform

[typedef]
struct C.sgp_state {
pub mut:
	frame_size    Isize
	viewport      Irect
	scissor       Irect
	proj          Mat2x3
	transform     Mat2x3
	mvp           Mat2x3
	color         Color
	images        ImagesUniform
	uniform       Uniform
	blend_mode    BlendMode
	pipeline      gfx.Pipeline
	_base_vertex  u32
	_base_uniform u32
	_base_command u32
}

pub type State = C.sgp_state

[typedef]
struct C.sgp_desc {
pub mut:
	max_vertices u32
	max_commands u32
}

pub type Desc = C.sgp_desc

[typedef]
struct C.sgp_pipeline_desc {
pub mut:
	shader         gfx.ShaderDesc    // Sokol shader description.
	primitive_type gfx.PrimitiveType // Draw primitive type (triangles, lines, points, etc). Default is triangles.
	blend_mode     BlendMode // Color blend mode. Default is no blend.
}

pub type PipelineDesc = C.sgp_pipeline_desc

// C: `SOKOL_GP_API_DECL void sgp_setup(const sgp_desc* desc); /* Initializes the SGP context, and should be called after `sg_setup`. */`
fn C.sgp_setup(const_desc &Desc)

// setup initializations and de-initialization.
// setup initializes the SGP context, and should be called after `sg_setup`.
pub fn setup(const_desc &Desc) {
	C.sgp_setup(const_desc)
}

// C: `SOKOL_GP_API_DECL void sgp_shutdown(void);/* Destroys the SGP context. */`
fn C.sgp_shutdown()

// shutdown destroys the SGP context.
pub fn shutdown() {
	C.sgp_shutdown()
}

// C: `SOKOL_GP_API_DECL bool sgp_is_valid(void);/* Checks if SGP context is valid, should be checked after `sgp_setup`. */`
fn C.sgp_is_valid() bool

// is_valid checks if SGP context is valid, should be checked after `sgp_setup`.
pub fn is_valid() bool {
	return C.sgp_is_valid()
}

// C: `SOKOL_GP_API_DECL sgp_error sgp_get_last_error(void); /* Returns last SGP error. */`
fn C.sgp_get_last_error() SGPError

// get_last_error errors handling.
// get_last_error returns last SGP error.
pub fn get_last_error() SGPError {
	return C.sgp_get_last_error()
}

// C: `SOKOL_GP_API_DECL const char* sgp_get_error_message(sgp_error error); /* Returns a message with SGP error description. */`
fn C.sgp_get_error_message(error SGPError) &char

// get_error_message returns a message with SGP error description.
pub fn get_error_message(error SGPError) &char {
	return C.sgp_get_error_message(error)
}

// C: `SOKOL_GP_API_DECL sg_pipeline sgp_make_pipeline(const sgp_pipeline_desc* desc); /* Creates a custom shader pipeline to be used with SGP. */`
fn C.sgp_make_pipeline(const_desc &PipelineDesc) gfx.Pipeline

// make_pipeline customs pipeline creation.
// make_pipeline creates a custom shader pipeline to be used with SGP.
pub fn make_pipeline(const_desc &PipelineDesc) gfx.Pipeline {
	return C.sgp_make_pipeline(const_desc)
}

// C: `SOKOL_GP_API_DECL void sgp_begin(int width, int height);/* Begins a new SGP draw command queue. */`
fn C.sgp_begin(width int, height int)

// begin draws command queue management.
// begin begins a new SGP draw command queue.
pub fn begin(width int, height int) {
	C.sgp_begin(width, height)
}

// C: `SOKOL_GP_API_DECL void sgp_flush(void); /* Dispatch current Sokol GFX draw commands. */`
fn C.sgp_flush()

// flush dispatchs current Sokol GFX draw commands.
pub fn flush() {
	C.sgp_flush()
}

// C: `SOKOL_GP_API_DECL void sgp_end(void); /* End current draw command queue, discarding it. */`
fn C.sgp_end()

// end ends current draw command queue, discarding it.
pub fn end() {
	C.sgp_end()
}

// C: `SOKOL_GP_API_DECL void sgp_project(float left, float right, float top, float bottom); /* Set the coordinate space boundary in the current viewport. */`
fn C.sgp_project(left f32, right f32, top f32, bottom f32)

// project 2ds coordinate space projection
// project sets the coordinate space boundary in the current viewport.
pub fn project(left f32, right f32, top f32, bottom f32) {
	C.sgp_project(left, right, top, bottom)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_project(void); /* Resets the coordinate space to default (coordinate of the viewport). */`
fn C.sgp_reset_project()

// reset_project resets the coordinate space to default (coordinate of the viewport).
pub fn reset_project() {
	C.sgp_reset_project()
}

// C: `SOKOL_GP_API_DECL void sgp_push_transform(void);/* Saves current transform matrix, to be restored later with a pop. */`
fn C.sgp_push_transform()

// push_transform 2ds coordinate space transformation.
// push_transform saves current transform matrix, to be restored later with a pop.
pub fn push_transform() {
	C.sgp_push_transform()
}

// C: `SOKOL_GP_API_DECL void sgp_pop_transform(void); /* Restore transform matrix to the same value of the last push. */`
fn C.sgp_pop_transform()

// pop_transform restores transform matrix to the same value of the last push.
pub fn pop_transform() {
	C.sgp_pop_transform()
}

// C: `SOKOL_GP_API_DECL void sgp_reset_transform(void); /* Resets the transform matrix to identity (no transform). */`
fn C.sgp_reset_transform()

// reset_transform resets the transform matrix to identity (no transform).
pub fn reset_transform() {
	C.sgp_reset_transform()
}

// C: `SOKOL_GP_API_DECL void sgp_translate(float x, float y); /* Translates the 2D coordinate space. */`
fn C.sgp_translate(x f32, y f32)

// translate translates the 2D coordinate space.
pub fn translate(x f32, y f32) {
	C.sgp_translate(x, y)
}

// C: `SOKOL_GP_API_DECL void sgp_rotate(float theta); /* Rotates the 2D coordinate space around the origin. */`
fn C.sgp_rotate(theta f32)

// rotate rotates the 2D coordinate space around the origin.
pub fn rotate(theta f32) {
	C.sgp_rotate(theta)
}

// C: `SOKOL_GP_API_DECL void sgp_rotate_at(float theta, float x, float y);/* Rotates the 2D coordinate space around a point. */`
fn C.sgp_rotate_at(theta f32, x f32, y f32)

// rotate_at rotates the 2D coordinate space around a point.
pub fn rotate_at(theta f32, x f32, y f32) {
	C.sgp_rotate_at(theta, x, y)
}

// C: `SOKOL_GP_API_DECL void sgp_scale(float sx, float sy); /* Scales the 2D coordinate space around the origin. */`
fn C.sgp_scale(sx f32, sy f32)

// scale scales the 2D coordinate space around the origin.
pub fn scale(sx f32, sy f32) {
	C.sgp_scale(sx, sy)
}

// C: `SOKOL_GP_API_DECL void sgp_scale_at(float sx, float sy, float x, float y);/* Scales the 2D coordinate space around a point. */`
fn C.sgp_scale_at(sx f32, sy f32, x f32, y f32)

// scale_at scales the 2D coordinate space around a point.
pub fn scale_at(sx f32, sy f32, x f32, y f32) {
	C.sgp_scale_at(sx, sy, x, y)
}

// C: `SOKOL_GP_API_DECL void sgp_set_pipeline(sg_pipeline pipeline);/* Sets current draw pipeline. */`
fn C.sgp_set_pipeline(pipeline gfx.Pipeline)

// set_pipeline states change for custom pipelines.
// set_pipeline sets current draw pipeline.
pub fn set_pipeline(pipeline gfx.Pipeline) {
	C.sgp_set_pipeline(pipeline)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_pipeline(void);/* Resets to the current draw pipeline to default (builtin pipelines). */`
fn C.sgp_reset_pipeline()

// reset_pipeline resets to the current draw pipeline to default (builtin pipelines).
pub fn reset_pipeline() {
	C.sgp_reset_pipeline()
}

// C: `SOKOL_GP_API_DECL void sgp_set_uniform(const void* data, uint32_t size);/* Sets uniform buffer for a custom pipeline. */`
fn C.sgp_set_uniform(const_data voidptr, size u32)

// set_uniform sets uniform buffer for a custom pipeline.
pub fn set_uniform(const_data voidptr, size u32) {
	C.sgp_set_uniform(const_data, size)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_uniform(void); /* Resets uniform buffer to default (current state color). */`
fn C.sgp_reset_uniform()

// reset_uniform resets uniform buffer to default (current state color).
pub fn reset_uniform() {
	C.sgp_reset_uniform()
}

// C: `SOKOL_GP_API_DECL void sgp_set_blend_mode(sgp_blend_mode blend_mode); /* Sets current blend mode. */`
fn C.sgp_set_blend_mode(blend_mode BlendMode)

// set_blend_mode states change functions for the common pipelines.
// set_blend_mode sets current blend mode.
pub fn set_blend_mode(blend_mode BlendMode) {
	C.sgp_set_blend_mode(blend_mode)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_blend_mode(void);/* Resets current blend mode to default (no blending). */`
fn C.sgp_reset_blend_mode()

// reset_blend_mode resets current blend mode to default (no blending).
pub fn reset_blend_mode() {
	C.sgp_reset_blend_mode()
}

// C: `SOKOL_GP_API_DECL void sgp_set_color(float r, float g, float b, float a); /* Sets current color modulation. */`
fn C.sgp_set_color(r f32, g f32, b f32, a f32)

// set_color sets current color modulation.
pub fn set_color(r f32, g f32, b f32, a f32) {
	C.sgp_set_color(r, g, b, a)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_color(void); /* Resets current color modulation to default (white). */`
fn C.sgp_reset_color()

// reset_color resets current color modulation to default (white).
pub fn reset_color() {
	C.sgp_reset_color()
}

// C: `SOKOL_GP_API_DECL void sgp_set_image(int channel, sg_image image);/* Sets current bound texture in a texture channel. */`
fn C.sgp_set_image(channel int, image gfx.Image)

// set_image sets current bound texture in a texture channel.
pub fn set_image(channel int, image gfx.Image) {
	C.sgp_set_image(channel, image)
}

// C: `SOKOL_GP_API_DECL void sgp_unset_image(int channel);/* Remove current bound texture in a texture channel (no texture). */`
fn C.sgp_unset_image(channel int)

// unset_image removes current bound texture in a texture channel (no texture).
pub fn unset_image(channel int) {
	C.sgp_unset_image(channel)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_image(int channel);/* Resets current bound texture in a channel to default (white texture). */`
fn C.sgp_reset_image(channel int)

// reset_image resets current bound texture in a channel to default (white texture).
pub fn reset_image(channel int) {
	C.sgp_reset_image(channel)
}

// C: `SOKOL_GP_API_DECL void sgp_viewport(int x, int y, int w, int h);/* Sets the screen area to draw into. */`
fn C.sgp_viewport(x int, y int, w int, h int)

// viewport states change functions for all pipelines.
// viewport sets the screen area to draw into.
pub fn viewport(x int, y int, w int, h int) {
	C.sgp_viewport(x, y, w, h)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_viewport(void);/* Reset viewport to default values (0, 0, width, height). */`
fn C.sgp_reset_viewport()

// reset_viewport resets viewport to default values (0, 0, width, height).
pub fn reset_viewport() {
	C.sgp_reset_viewport()
}

// C: `SOKOL_GP_API_DECL void sgp_scissor(int x, int y, int w, int h); /* Set clip rectangle in the viewport. */`
fn C.sgp_scissor(x int, y int, w int, h int)

// scissor sets clip rectangle in the viewport.
pub fn scissor(x int, y int, w int, h int) {
	C.sgp_scissor(x, y, w, h)
}

// C: `SOKOL_GP_API_DECL void sgp_reset_scissor(void); /* Resets clip rectangle to default (viewport bounds). */`
fn C.sgp_reset_scissor()

// reset_scissor resets clip rectangle to default (viewport bounds).
pub fn reset_scissor() {
	C.sgp_reset_scissor()
}

// C: `SOKOL_GP_API_DECL void sgp_reset_state(void); /* Reset all state to default values. */`
fn C.sgp_reset_state()

// reset_state resets all state to default values.
pub fn reset_state() {
	C.sgp_reset_state()
}

// C: `SOKOL_GP_API_DECL void sgp_clear(void); /* Clears the current viewport using the current state color. */`
fn C.sgp_clear()

// clear drawings functions.
// clear clears the current viewport using the current state color.
pub fn clear() {
	C.sgp_clear()
}

// C: `SOKOL_GP_API_DECL void sgp_draw_points(const sgp_point* points, uint32_t count);/* Draws points in a batch. */`
fn C.sgp_draw_points(const_points &Vec2, count u32)

// draw_points draws points in a batch.
pub fn draw_points(const_points &Vec2, count u32) {
	C.sgp_draw_points(const_points, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_point(float x, float y);/* Draws a single point. */`
fn C.sgp_draw_point(x f32, y f32)

// draw_point draws a single point.
pub fn draw_point(x f32, y f32) {
	C.sgp_draw_point(x, y)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_lines(const sgp_line* lines, uint32_t count); /* Draws lines in a batch. */`
fn C.sgp_draw_lines(const_lines &Line, count u32)

// draw_lines draws lines in a batch.
pub fn draw_lines(const_lines &Line, count u32) {
	C.sgp_draw_lines(const_lines, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_line(float ax, float ay, float bx, float by); /* Draws a single line. */`
fn C.sgp_draw_line(ax f32, ay f32, bx f32, by f32)

// draw_line draws a single line.
pub fn draw_line(ax f32, ay f32, bx f32, by f32) {
	C.sgp_draw_line(ax, ay, bx, by)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_lines_strip(const sgp_point* points, uint32_t count); /* Draws a strip of lines. */`
fn C.sgp_draw_lines_strip(const_points &Vec2, count u32)

// draw_lines_strip draws a strip of lines.
pub fn draw_lines_strip(const_points &Vec2, count u32) {
	C.sgp_draw_lines_strip(const_points, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_filled_triangles(const sgp_triangle* triangles, uint32_t count);/* Draws triangles in a batch. */`
fn C.sgp_draw_filled_triangles(const_triangles &Triangle, count u32)

// draw_filled_triangles draws triangles in a batch.
pub fn draw_filled_triangles(const_triangles &Triangle, count u32) {
	C.sgp_draw_filled_triangles(const_triangles, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_filled_triangle(float ax, float ay, float bx, float by, float cx, float cy);/* Draws a single triangle. */`
fn C.sgp_draw_filled_triangle(ax f32, ay f32, bx f32, by f32, cx f32, cy f32)

// draw_filled_triangle draws a single triangle.
pub fn draw_filled_triangle(ax f32, ay f32, bx f32, by f32, cx f32, cy f32) {
	C.sgp_draw_filled_triangle(ax, ay, bx, by, cx, cy)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_filled_triangles_strip(const sgp_point* points, uint32_t count);/* Draws strip of triangles. */`
fn C.sgp_draw_filled_triangles_strip(const_points &Vec2, count u32)

// draw_filled_triangles_strip draws strip of triangles.
pub fn draw_filled_triangles_strip(const_points &Vec2, count u32) {
	C.sgp_draw_filled_triangles_strip(const_points, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_filled_rects(const sgp_rect* rects, uint32_t count);/* Draws a batch of rectangles. */`
fn C.sgp_draw_filled_rects(const_rects &Rect, count u32)

// draw_filled_rects draws a batch of rectangles.
pub fn draw_filled_rects(const_rects &Rect, count u32) {
	C.sgp_draw_filled_rects(const_rects, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_filled_rect(float x, float y, float w, float h);/* Draws a single rectangle. */`
fn C.sgp_draw_filled_rect(x f32, y f32, w f32, h f32)

// draw_filled_rect draws a single rectangle.
pub fn draw_filled_rect(x f32, y f32, w f32, h f32) {
	C.sgp_draw_filled_rect(x, y, w, h)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_textured_rects(const sgp_rect* rects, uint32_t count);/* Draws a batch of textured rectangles. */`
fn C.sgp_draw_textured_rects(const_rects &Rect, count u32)

// draw_textured_rects draws a batch of textured rectangles.
pub fn draw_textured_rects(const_rects &Rect, count u32) {
	C.sgp_draw_textured_rects(const_rects, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_textured_rect(float x, float y, float w, float h);/* Draws a single textured rectangle. */`
fn C.sgp_draw_textured_rect(x f32, y f32, w f32, h f32)

// draw_textured_rect draws a single textured rectangle.
pub fn draw_textured_rect(x f32, y f32, w f32, h f32) {
	C.sgp_draw_textured_rect(x, y, w, h)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_textured_rects_ex(int channel, const sgp_textured_rect* rects, uint32_t count); /* Draws a batch textured rectangle, each from a source region. */`
fn C.sgp_draw_textured_rects_ex(channel int, const_rects &TexturedRect, count u32)

// draw_textured_rects_ex draws a batch textured rectangle, each from a source region.
pub fn draw_textured_rects_ex(channel int, const_rects &TexturedRect, count u32) {
	C.sgp_draw_textured_rects_ex(channel, const_rects, count)
}

// C: `SOKOL_GP_API_DECL void sgp_draw_textured_rect_ex(int channel, sgp_rect dest_rect, sgp_rect src_rect); /* Draws a single textured rectangle from a source region. */`
fn C.sgp_draw_textured_rect_ex(channel int, dest_rect Rect, src_rect Rect)

// draw_textured_rect_ex draws a single textured rectangle from a source region.
pub fn draw_textured_rect_ex(channel int, dest_rect Rect, src_rect Rect) {
	C.sgp_draw_textured_rect_ex(channel, dest_rect, src_rect)
}

// C: `SOKOL_GP_API_DECL sgp_state* sgp_query_state(void); /* Returns the current draw state. */`
fn C.sgp_query_state() &State

// query_state queryings functions.
// query_state returns the current draw state.
pub fn query_state() &State {
	return C.sgp_query_state()
}

// C: `SOKOL_GP_API_DECL sgp_desc sgp_query_desc(void);/* Returns description of the current SGP context. */`
fn C.sgp_query_desc() Desc

// query_desc returns description of the current SGP context.
pub fn query_desc() Desc {
	return C.sgp_query_desc()
}
